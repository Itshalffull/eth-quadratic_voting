//Basic data
data voters[](exists, level)
data proposals[](exists, name, description, startDate,endDate, voteCost, yesVotes, noVotes, money, voters[](exists, votes, yesOrNo))

//@todo Make a concept of "organizations" so you don't have to be ridiculous like this"
def registerAdmin():
    self.voters[msg.sender].level = 1

def registerProposal(contractID, proposalName, proposalDescription,proposalStartDate, proposalEndDate, proposalVoteCost):
    //Check Permissions
    if self.voters[msg.sender].level = 1:
        //Sanity checks
        if not self.proposals[contractID].exists and proposalStartDate >= block.timestamp and proposalendDate > proposalStartDate:
            //Initialize the proposal
            self.proposals[contractID].exists = 1
            self.proposals[contractID].name = proposalName
            self.proposals[contractID].description = proposalDescription
            self.proposals[contractID].startDate = proposalStartDate
            self.proposals[contractID].endDate = proposalEndDate
            self.proposals[contractID].voteCost = proposalVoteCost
            self.proposals[contractID].yesVotes = 0
            self.proposals[contractID].noVotes = 0
            self.proposals[contractID].money = 0


def registerVoter(voterID, levelPipe):
    //"Admin" that can register voters
    if self.voters[msg.sender].level == 1:
        //@todo get rid of this whole idea of levels and just have an organization
        self.voters[voterID].exists = 1
        self.voters[voterID].level = levelPipe


def voteCount(costForVote):
    //@todo allow for mulitple voting rounds.
    return ((msg.value/costForVote)**(1/2))

def vote(proposal, forOrAgainst):
    if self.voters[msg.sender].level >= 0 and self.proposals[proposal].exists:
        if not self.proposals[proposal].voters[msg.sender].exists and block.timestamp < self.proposals[proposal].endDate:
            voteAmount = voteCount(self.proposals[proposal].voteCost)
            moneySpent = (voteAmount * self.proposals[proposal].voteCost) ** 2
            moneyLeft = msg.value - moneySpent
            //Return the unused money
            send(msg.sender,moneyLeft)
            //Tally the votes
            self.proposals[proposal].voters[msg.sender].votes = voteAmount
            //Against Vote
            if forOrAgainst = 0:
                self.proposals[proposal].noVotes += voteAmount
                self.proposals[proposal].voters[msg.sender].yesOrNo = 0
            //For Vote
            if forOrAgainst = 1:
                self.proposals[proposal].yesVotes += voteAmount
                self.proposals[proposal].voters[msg.sender].yesOrNo = 0
